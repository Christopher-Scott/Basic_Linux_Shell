char * args_Array[] // to hold the arguments off the command line
char **Line // pointer to hold the command line input
char **PATH // copy of environment path
queue *queue

Main()
	// Batch Mode
	Open file specified in cmd args
	While (not EOF)
		read line from batch file
		Parse(line, args_array)
		Case: input is a built-in
			Run the built-in
		Case: input is an executable
			for each directory in path:
				if access(path + cmd) is successful:
					concat path + cmd
					break
			If: output/input redirection
				Evaluate args_array for filenames
				dup() stdin or stdout to temporary variable
				close stdin or stdout
				open file into stdin or stdout fd
			If: piping
				Create pipe
				Fork
				if child:
					duplicate stdin to read-end of pipe
					exec input process
				if parent:
					duplicate stdout to write-end of pipe
					exec output process
			else:
				Fork the shell
				Exec the file at path with Args_Array
			If background process:
				continue to next iteration without waiting
			else:
				wait
		If: redirection
			dup2() temporary copy back into destination
			close copies
		Close files

	// Interactive Mode
	While (not EOF and line != ‘exit’)
		Print prompt
		Get line from user input
		parse(line, queue)
		// handle a single line
		current cmd = create_argv(queue)
		while command queue not empty:
			peek at the next command in the queue
			// Input redirection can be followed by at most one output redirection
			// Input redireciton can be followed by pipes
			// Output redirection can not be followed by anything
			if next command is redirection:
				// what if the following command is a pipe
				next = create_argv(queue)
				if cmd is built in:
					parse cmd and call built in with next
				else:
					dup() stdin or stdout to temporary variable
					close stdin or stdout
					open file into stdin or stdout fd
			if next command is pipe:
				//TODO: How are built ins handled here
				// build array of chained pipes
				arr[0] = cmd
				while next_cmd is pipe:
					arr[i] = next_cmd
					next_cmd = create_argv(queue)
				int read = 0
				for each n - 1 pipes:
					pipe(fd)
					fork
					if child:
						if read is not 0:
							dup2(read, 0)
						if fd[1] is not 1:
							dup2(fd[1], 1)
						exec(arr[i]->cmd)

					if parent:
						read = fd[0] // store the read end of the pipe for next
				// Last command gets read input only
				fork
					dup2(read, 0)
					exec(last command)

			Case: input is a built-in
				Run the built-in

			Case: input is an executable
				Look in path for the executable file and construct file path
				Fork the shell
				Exec the file at path with current argv
				If background process:
					continue to next iteration without waiting
				else:
					wait
		Close files

int parse(char *cmd_string, arg_array)
	while strtok(cmd_string) not NULL:
		enqueue token

char **create_argv(*queue)
	dequeue tokens from queue until next command/keyword is found
	build arg vector
	return arg vector

// Command string is tokenized, then tokens are traversed building the next Command
// to add to the command queue
int parse(char *cmd_string, queue *)
	// queue consists of nodes, something like:
	struct cmd_node{
	char * cmd;
	char * argv;
	char * inputfile;
	char * outputfile;
	cmd_node * pipe_in; // a pointer to the next command in a pipe chain
	int background;
	}

	while cmd_string is not NULL
	while temp not empty:
		case cmd:
			build array of tokens with command at arr[0] and args after
			Null terminate
			enqueue()
		case pipe:
			arr[0] = '|'
			get previous cmd_arr
			arr[1] = previous cmd_arr // input command
			get next cmd_arr // loop until another command is found or end
			arr[2] = next cmd_arr // output command
			replace previous cmd_arr in command queue with new pipe_arr
		case input redirect:
			arr[0] = '<'
			get previous cmd_arr
			arr[1] = previous cd_arr
			arr[2] = next token // input file
			replace previous cmd_arr in command queue with new input_arr
		case output redirect:
			arr[0] = '>'
			get previous cmd_arr
			arr[1] = cmd_arr
			arr[2] = next token // output file
			replace previous cmd_arr in command queue with new output_arr
		case append redirect:
			arr[0] = ">>"
			get previous cmd_arr
			arr[1] = cmd_arr
			arr[2] = next token // output file
			replace previous cmd_arr in command queue with new output_arr
		return command queue




// Built Ins
cd(char * path)
	If path is NULL:
		get cwd from environ path
		print cwd
	else:
		if chdir(path) < 0:
			print error

clr(void)
	print clear screen string

dir(char *path)
	if path is NULL:
		get cwd from environ path
		path = cwd
	opendir(path)
	While readir(dir) is not NULL:
		Print the name of the file

environ(char *var)
	if var is NULL:
		Get environment variables
		Loop over environment variables array:
			print
	else:
		Get environment variables
		find var
		print


echo(char *comment)
	print comment to stdout followed by newline

help(void)
	Open manual file
	fork
	if child:
		exec 'more' with file as argument
	else:
		wait()

pause(void)
	while getchar is not 'enter'
	flush stdin

quit(void)
	shut everything down and call exit()

// Questions
- Do we need to support piping for built ins?
- Why does redirection need to be supported internally for built ins?
- Do we need to implement arbitrarily long chains of pipes?
- Does cd print an error on no argument (conflicting instructions)

// Development and Testing Paradigms
-Built-ins and key functions for the operation of the program will be in separate files
 from the main program.
-Unit tests will be created for functions and built ins
-Program will be developed with increasing degrees of functionality that can be tested at each step
	1. Construct main loop to take arguments and parse, but print output instead of executing
	2. Write any additional functions necessary to complete the main loop
	3. Implement logic for process execution
	4. Implement Piping and redirection
	5. Apply logic from main loop to processing batch files
